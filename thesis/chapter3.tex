%%%%%%%%%%% System Analysis and Design %%%%%%%%%%%%%%%%%
\chapter{System Analysis and Design} \label{ch3_design}
\markboth{System Analysis and Design}{System Analysis and Design}

Building upon the theoretical foundations of distributed ledger technologies presented in Chapter~\ref{ch2_theoretical_framework}, this chapter introduces the high-level system design of the proposed educational blockchain system. The primary challenge in designing this system lies in balancing production-level functionality with educational clarity. To address this challenge, the system is architected according to a modular design approach. This approach enables complex subsystems, such as the networking layer or the consensus engine, to be isolated, inspected, and modified independently. Consequently, students can experiment with and extend individual components without necessitating extensive refactoring or introducing unintended side effects across the codebase.

\section{Requirement Analysis}
\label{ch3_requirements}

The system requirements were derived from the educational objectives of the curriculum modules defined in Chapter~\ref{ch5_curriculum}. Following software engineering best practices, the requirements are categorized into the following two sections: Non-Functional Requirements and Functional Requirements~\cite{sommerville2011software}.

\subsection{Non-Functional Requirements}

\begin{enumerate}
    \item \textbf{Modularity:}  
    The codebase must follow the principle of Separation of Concerns. In particular, networking functionality must be decoupled from core business and ledger logic to facilitate modifications and extensibility.

    \item \textbf{Readability:}  
    As the system is intended for educational use, source code readability must be prioritized over production-level optimizations. The implementation should leverage Python's readable syntax to enhance conceptual understanding.

    \item \textbf{Deployability:}  
    The system must support containerization using Docker to ensure consistent deployment and execution across different student operating systems.
\end{enumerate}

\subsection{Functional Requirements}

To function as an educational platform for computer science students and individuals interested in the technical foundations of blockchain systems, the implementation must support the following core capabilities:

\begin{enumerate}
    \item \textbf{Peer-to-Peer Networking:}  
    The system must discover peers and propagate blocks and transactions through a TCP-based gossip protocol~\cite{coulouris2011distributed}.

    \item \textbf{Pluggable Consensus Mechanisms:}  
    The system's architecture must facilitate the replacement of consensus algorithms (e.g., switching between Proof of Work and Proof of Stake), without requiring modifications to the other modules in the codebase.

    \item \textbf{State Management:}  
    The system must maintain a persistent ledger state, supporting the account-based model, and must automatically resolve forks using the longest-chain rule.

    \item \textbf{System Observability:}  
    A RESTful API must expose internal system metrics such as mempool size, peer count, and the latest block hash to enable integration with a graphical blockchain explorer.
\end{enumerate}


\section{System Architecture} \label{ch3_architecture}

The system architecture adopts a multi-layered architecture pattern, dividing the system into three layers: the Networking Layer, the Core Blockchain Layer, and the Application Interface Layer (API).

\subsection{The Networking Layer (P2P)}
This layer handles the raw TCP socket connections. It implements a custom message handler that serializes Python objects into JSON payloads for transmission. By abstracting the networking logic here, the upper layers can simply invoke \enquote{broadcast(message)} without managing the connection states.

\subsection{The Core Blockchain Layer}
This is the central engine of the system. It contains the data structures (Block, Transaction) and the validation logic. To support the educational requirement of swappable consensus mechanisms, the \enquote{Blockchain} class is designed to delegate block validation and creation to a dedicated consensus component. Rather than including the mining or staking logic directly within the blockchain management component, the blockchain instantiates a specific consensus class (e.g., `ProofOfStake` or `ProofOfWork`). This approach allows the consensus algorithm to be replaced or modified in isolation without affecting the transaction processing or peer-to-peer logic.

\subsection{The Application Interface Layer (API)}
The Application Interface Layer serves as the primary gateway for external interaction with the blockchain node. It exposes a comprehensive set of RESTful endpoints that provide real-time access to the node's internal state, including the transaction pool, block history, and peer connections. This layer acts as the backend for the \enquote{Blockchain Explorer} visualization tool and empowers students to interact programmatically with the system. During laboratory exercises, students can manually trigger specific network behaviors such as initiating peer connections (e.g., via `POST /connect\_peer`) or submitting transactions thereby facilitating active experimentation and debugging.

\section{Detailed Component Design} \label{ch3_detailed_design}

\subsection{Class Design and Relationships}
The object oriented structure of the system is designed to mirror the theoretical components of a blockchain. Figure~\ref{fig:class_diagram} illustrates the relationships between the core classes.


Key relationships include:
\begin{itemize}
    \item \textbf{Composition:} The `Node` class maintains a `Blockchain` instance and a `TransactionPool`.
    \item \textbf{Aggregation:} The `Blockchain` contains a list of `Block` objects.
    \item \textbf{Component-based Consensus:} The `Blockchain` integrates a dedicated consensus class. In the reference system implemented in Chapter~\ref{ch4_implementation}, this is the `ProofOfStake` component. This design choice simplifies the initial codebase while retaining the flexibility to swap the consensus mechanism (e.g., to `ProofOfWork`) as an educational exercise in Chapter~\ref{ch5_curriculum}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth, height=1\textheight, keepaspectratio]{figures/Blockchain_Architecture.png}
    \caption{Simplified Component Class Diagram illustrating the relationship between Node, Blockchain, and Consensus.}
    \label{fig:class_diagram}
\end{figure}


\subsection{Data Flow and Transaction Lifecycle}
Understanding how data moves through the system is critical for the \enquote{Performance Analysis} module in Chapter~\ref{ch5_curriculum}. Figure~\ref{fig:tx_flow} illustrates the transaction lifecycle using a UML Activity Diagram, where partitions (swimlanes) are employed to delineate the specific system components—such as the Node, P2P Network, and Consensus engine—responsible for each stage of execution. Additionally, the diagram adheres to standard UML conventions by utilizing rhombus-shaped decision nodes to represent control flow divergence based on boolean conditions, such as signature validation and loop checks.

\begin{figure}[H]
    \centering
    \includegraphics[height=1\textheight, keepaspectratio]{figures/transaction_lifecycle_activity.png}
    \caption{Transaction Activity Diagram: Illustrating the sequence of operations from creation to finalization.}
    \label{fig:tx_flow}
\end{figure}


\newpage

The flow proceeds as follows:
\begin{enumerate}
    \item \textbf{Creation:} A client signs a transaction using their private key.
    \item \textbf{Propagation:} The transaction is sent to the Node API and broadcast to the P2P network.
    \item \textbf{Pooling:} Valid transactions are stored in the `TransactionPool` (mempool).
    \item \textbf{Packaging:} The consensus engine selects transactions from the pool to create a candidate block.
    \item \textbf{Finalization:} Once the new block is validated, it is appended to the chain, and the transactions are removed from the pool.
\end{enumerate}

\section{Technology Stack Justification} \label{ch3_tech_stack}

\subsection{Python as the Core Language}
Python was selected as the implementation language primarily due to its prevalence in educational contexts and in data science. Unlike C++, which requires complex manual memory management, Python enables students to focus on the core logic of the blockchain system rather than low-level implementation details.

\subsection{Docker for Environment Isolation}
To simulate a distributed network on a single machine, Docker containers are utilized. Each node runs in its own isolated container with a unique IP address within the Docker virtual network. This allows students to simulate network partitions and latency without requiring dedicated physical hardware.

\section{Summary}
This chapter defined the architectural blueprint of the educational blockchain. By utilizing a modular, layered architecture, the system satisfies the requirements for an extensible and clear learning platform. This design sets the stage for the detailed implementation discussed in Chapter~\ref{ch4_implementation} and the curriculum exercises presented in Chapter~\ref{ch5_curriculum}.